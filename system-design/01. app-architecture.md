b> 10 - Nov - 2024

## TimeLine

* Day 1 - App Architectures
* Day 2 - App Performance
* Day 3 - App Scalability
* Day 4 - Micro-service Architecture
* Day 5 - App Reliability
* Day 6 - App Security
* Day 7 - Technology Stack
* Day 8-10 - System Design Case Studies

## Day 1 - App Architectures

* Beyond framework - how to an app architecture `or` how to design a big system `or` by building an app in which key area need to look for better design... so to build an app which architecture we will need to figure out that.

* Which architecture we need to follow...? so
  * What are the architectures options??? (client-server arch...)
    1. Monolithic
    2. 2-Tier
    3. N-Tier
    4. Modular Monolith
    5. Micro-service
    6. Event Driven
    7. Cloud Native
    8. Serverless
    9. Mixed Way / Hybrid / ETC...

<br/>

## 1. Monolithic

Monolithic architecture - refers to a software application design. <br/>
where all components are `tightly coupled` & integrated into a single, self-contained unit. <br/>
Imagine a large building constructed from a single piece of stone. <br/>
that's the essence of a monolithic architecture. <br/>

`Note:` its a **single tier architecture** <br/>

* Logical layer called - `tier`
  * User Interface - layer
  * Business Logic - layer
  * Data Interface - layer
  * Database - layer <br/> so these layer is called `tier`

To be honest we never do monolithic arch/code  directly. <br/>
our code based goes into multiple layers/tiers... <br/>
so we don't follow the exact monolithic architecture <br/>

ever app 1st start its journey by monolithic architecture. <br/>
window, linux, mac-os are monolithic architecture based app <br/>

* **Key Characteristics**
  * Single Codebase
  * Centralized Deployment
  * Shared Database
  * Tight Coupling **(module data communication)**

|No| Advantage        | Disadvantage            |
|--|------------------|-------------------------|
|1 | Simplicity       | Scalability             |
|2 | Maintainability  | Maintainability         |
|3 | Cost-effective   | Agility                 |
|4 | Performance      | Single point of failure |

`Agility:` Difficult to implement frequently small new features or updates without affecting the entire app. <br/>
**Small update loop not possible** in this monolithic architecture. Modularity approach is not present here. <br/>
Little update effect at whole app. So its become **single point of failure** <br/>

<br/><br/>

## 2. 2-Tier

A 2-tier architecture is a software architecture pattern, that divides the application into two distinct layers:

1. `(Client) Presentation Tier`: This layer handles the **user interface** & interacts with the user directly.
2. `(Server) Data Tier`: This layer handles the **business logic**, **data storage**, & **processing**.

So when you break your app into different layers, you are increasing complexity of the application... <br/>

|No| Advantage                          | Disadvantage                |
|--|------------------------------------|-----------------------------|
|1 | Improved scalability               | Increased complexity        |
|2 | Enhanced maintainability           | Additional network traffic  |
|3 | Increased security                 | Single point of failure     |
|4 | Flexibility in technology choices  |                             |
|5 | Simplified deployment              |                             |
|6 | Performance benefits               |                             |

<br/><br/>

## 3. N-Tier || 3-Tier

N-tier architecture, also known as multi-tier architecture, is a software architecture pattern <br/>
that separates the application into multiple layers, each with distinct responsibilities.

1. Presentation Tier
2. Business Logic Tier
3. Data Access Layer
4. Integration Tier (Optional)

|No| Advantage                          | Disadvantage                    |
|--|------------------------------------|---------------------------------|
|1 | Improved scalability               | Increased complexity            |
|2 | Enhanced maintainability           | Additional network traffic      |
|3 | Increased security                 | Increased Debugging Difficulty  |
|4 | Flexibility in technology choices  |                                 |
|5 | Simplified deployment              |                                 |

<br/><br/>

## 4. Modular Monolith **

A modular monolithic architecture is a software development approach <br/>
that combines the benefits of modular design with the simplicity of a monolithic architecture. <br/>
It aims to address some of the limitations of traditional monolithic architectures while still retaining their advantages. <br/>

* **Key Characteristics**
  * Single Codebase
  * Independent Modules
  * Loose Coupling **(module data communication)** ***(by public/private api || function call)***
  * Shared Resources

|No| Advantage                | Disadvantage              |
|--|--------------------------|---------------------------|
|1 | Improved maintainability | Potential coupling issues |
|2 | Increased `agility`      | Limited scalability       |
|3 | Enhanced testability     | Single point of failure   |
|4 | Reduced complexity       |                           |
|5 | Cost-effective           |                           |

* Its a flavor of Micro-services, so its very easy to move in Micro-services architecture from this architecture.

<br/><br/>

## 5. Micro-service

Microservice architecture is a software development approach that structures an application as </br>
a collection of `small`, `independent`, & `loosely coupled` services/application. </br>
Each service is **self-contained** & **focuses** on a **single business capability**. </br>
Services **communicate** with each other through <u>well-defined APIs</u> </br>
The more we increase the service, the more we increase complexity of an application

* Key Characteristics
  * Independent Service
  * Loose Coupling **(module data communication)** ***(by public/private api || function call)***
  * Lightweight Technologies
  * Decentralized Data
  * Continuous Delivery

|No| Advantage                          | Disadvantage              |
|--|------------------------------------|---------------------------|
|1 | Improved Scalability               | Increased Complexity      |
|2 | Enhanced `agility`                 | Distributed Debugging     |
|3 | Increased Fault Tolerance          | Infrastructure Overhead   |
|4 | Simplified Maintenance             | Network Latency           |
|5 | Flexibility in Technology Choices  | Data Consistency          |

<br/><br/>

# Note

* ⬆️ above all these architectures are used to `design` for stand-alone `main applications` & </br>
  ⬇️ bellow all these architectures are used to `work with` `all other architectures`...
  
## 6. Event Driven

<br/><br/>

## 7. Cloud Native

<br/><br/>

## 8. Serverless

<br/><br/>

## 9. Mixed Way / Hybrid / ETC
